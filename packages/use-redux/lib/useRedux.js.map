{"version":3,"file":"useRedux.js","sourceRoot":"","sources":["../src/useRedux.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react'\nimport { Store, Action } from 'redux'\n\nexport type TSelectedState = any\nexport type TStoreState = any\nexport interface ISelector {\n  (...sources: any[]): any\n}\nexport type TActionCreator = (payload: any) => Action\nexport type TPayloadTransformer = ((Action: any) => Action) | any\nexport type TDispatcher = (dispatch: Store['dispatch'], ...args: any[]) => void\n\n/*\n * shouldUpdate:\n *   true - always update\n *   function - update if true == shouldUpdate(nextSelectedState, prevSelectedState, ?storePrevSelectedState(prevSelectedState))\n *   (default) - update if nextSelectedState !== prevSelectedState\n *\n */\nexport type TShouldUpdate =\n  | boolean\n  | ((\n      nextSelectedState: TSelectedState,\n      prevSelectedState: TSelectedState,\n      storePrevSelectedState?: (prevSelectedState: TSelectedState) => void\n    ) => boolean)\n\n/*\n * shouldSelect:\n *   function - select if true == shouldSelect(nextStoreState, prevStoreState)\n *   (default) - always select\n */\nexport type TShouldSelect = (nextStoreState: TStoreState, prevStoreState: TStoreState) => boolean\n\nconst UNSET_MARKER = {}\n\nexport default function useRedux(\n  store: Store,\n  selector: ISelector,\n  shouldUpdate: TShouldUpdate,\n  shouldSelect: TShouldSelect\n) {\n  const [{ selectedState }, setSelectedState] = React.useState(() => {\n    return { selectedState: selector(store.getState()) }\n  })\n\n  const customShouldSelect = 'function' === typeof shouldSelect\n  const customShouldUpdate = 'function' === typeof shouldUpdate\n\n  const refPrevStoreState = React.useRef<TStoreState>(void 0)\n  const refPrevSelectedState = React.useRef<TSelectedState>(UNSET_MARKER)\n  React.useEffect(() => {\n    refPrevStoreState.current = customShouldSelect ? store.getState() : null\n    if (customShouldUpdate) {\n      let prevSelectedStateUpdated = false\n      shouldUpdate(\n        selectedState,\n        UNSET_MARKER === refPrevSelectedState.current ? selectedState : refPrevSelectedState.current,\n        prevSelectedState => {\n          refPrevSelectedState.current = prevSelectedState\n          prevSelectedStateUpdated = true\n        }\n      )\n      if (!prevSelectedStateUpdated) {\n        refPrevSelectedState.current = selectedState\n      }\n    } else if (true !== shouldUpdate) {\n      refPrevSelectedState.current = selectedState\n    }\n  }, [store, selector, shouldUpdate, shouldSelect])\n\n  const refSubscription = React.useRef<(nextStoreState: TStoreState) => void>(null)\n  refSubscription.current = React.useCallback(\n    (nextStoreState: TStoreState) => {\n      if (!customShouldSelect || shouldSelect(nextStoreState, refPrevStoreState.current)) {\n        const nextSelectedState = selector(nextStoreState)\n        let prevSelectedStateUpdated = false\n        if (\n          true === shouldUpdate ||\n          (customShouldUpdate &&\n            shouldUpdate(nextSelectedState, refPrevSelectedState.current, prevSelectedState => {\n              refPrevSelectedState.current = prevSelectedState\n              prevSelectedStateUpdated = true\n            })) ||\n          (!customShouldUpdate && nextSelectedState !== refPrevSelectedState.current)\n        ) {\n          setSelectedState({ selectedState: nextSelectedState })\n          if (!prevSelectedStateUpdated && true !== shouldUpdate) {\n            refPrevSelectedState.current = nextSelectedState\n          }\n        }\n      }\n      if (customShouldSelect) {\n        refPrevStoreState.current = nextStoreState\n      }\n    },\n    [selector, shouldUpdate, shouldSelect]\n  )\n\n  React.useEffect(() => {\n    const unsubscribe = store.subscribe(() => {\n      refSubscription.current(store.getState())\n    })\n    return () => {\n      unsubscribe()\n    }\n  }, [store])\n\n  return selectedState\n}\n\nexport function useDispatchAction(\n  store: Store,\n  actionCreator: TActionCreator,\n  payloadTransformer?: TPayloadTransformer\n) {\n  return React.useCallback(\n    payload =>\n      void 0 === payloadTransformer\n        ? store.dispatch(actionCreator(payload))\n        : 'function' === typeof payloadTransformer\n        ? store.dispatch(actionCreator(payloadTransformer(payload)))\n        : store.dispatch(actionCreator(payloadTransformer)),\n    [store, actionCreator, payloadTransformer]\n  )\n}\n\nexport function useDispatch(store: Store, dispatcher: TDispatcher, deps: any[] = []) {\n  return React.useCallback((...args) => dispatcher(store.dispatch, ...args), [store, ...deps])\n}\n\nexport function combineSelectors(\n  selectorsMap: { [key: string]: ISelector },\n  {\n    selectedStatesEqual\n  }: {\n    selectedStatesEqual?: (\n      selectorKey: string,\n      nextSelectedState: TSelectedState,\n      prevSelectedState: TSelectedState\n    ) => boolean\n  } = {}\n) {\n  const selectorKeys = Object.keys(selectorsMap)\n  const combinedSelectors: {\n    selector: ISelector\n    shouldUpdate: Exclude<TShouldUpdate, boolean>\n    areEqual: (nextSelectedState: TSelectedState, prevSelectedState: TSelectedState) => boolean\n  } = {\n    selector: (...sources) => {\n      const selectedState: { [key: string]: TSelectedState } = {}\n      for (let i = 0; i < selectorKeys.length; i++) {\n        const selectorKey = selectorKeys[i]\n        selectedState[selectorKey] = selectorsMap[selectorKey](...sources)\n      }\n      return selectedState\n    },\n    shouldUpdate: selectedStatesEqual\n      ? (nextSelectedState, prevSelectedState, storePrevSelectedState) => {\n          for (let i = 0; i < selectorKeys.length; i++) {\n            const selectorKey = selectorKeys[i]\n            if (!selectedStatesEqual(selectorKey, nextSelectedState[selectorKey], prevSelectedState[selectorKey])) {\n              return true\n            }\n          }\n          if (storePrevSelectedState) {\n            storePrevSelectedState(prevSelectedState)\n          }\n          return false\n        }\n      : (nextSelectedState, prevSelectedState, storePrevSelectedState) => {\n          for (let i = 0; i < selectorKeys.length; i++) {\n            const selectorKey = selectorKeys[i]\n            if (nextSelectedState[selectorKey] !== prevSelectedState[selectorKey]) {\n              return true\n            }\n          }\n          if (storePrevSelectedState) {\n            storePrevSelectedState(prevSelectedState)\n          }\n          return false\n        },\n    areEqual: (nextSelectedState, prevSelectedState) =>\n      !combinedSelectors.shouldUpdate(nextSelectedState, prevSelectedState)\n  }\n  return combinedSelectors\n}\n\nexport function connect(\n  store: Store,\n  selector: ISelector,\n  shouldUpdate: TShouldUpdate,\n  shouldSelect: TShouldSelect,\n  dispatch = store.dispatch\n) {\n  const emptyObject = {}\n  const emptySelector = () => emptyObject\n\n  return function (\n    Component: React.ComponentType,\n    mapToProps?: (selected: TSelectedState, props: any, dispatch: typeof store.dispatch) => any\n  ) {\n    function ConnectedComponent(props: any) {\n      const refProps = React.useRef<any>(props)\n      refProps.current = props\n      const safeSelector = React.useCallback(\n        selector ? state => selector(state, refProps.current) || emptyObject : emptySelector,\n        []\n      )\n      const selected = useRedux(store, safeSelector, shouldUpdate, shouldSelect)\n      const connectedProps = (mapToProps ? mapToProps(selected, props, dispatch) : selected) || emptyObject\n      return <Component {...props} {...connectedProps} />\n    }\n    ConnectedComponent.displayName = `connect(${Component.displayName || Component.name || 'Component'})`\n    return ConnectedComponent\n  }\n}\n"]}