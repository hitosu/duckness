{"version":3,"file":"store.js","sourceRoot":"","sources":["../src/store.ts"],"names":[],"mappings":"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","sourcesContent":["import { useEffect, useState, useRef } from 'react'\n\nexport type TState = any\nexport type TValue = any\nexport interface ISelector {\n  (...sources: any[]): any\n}\nexport interface IUpdater {\n  (currentState: TState): TState\n}\nexport interface IListener {\n  (value: TValue): void\n  selector?: (storeState: TState) => TValue\n  shouldUpdate?: (nextValue: TValue, prevValue: TValue) => boolean\n  shouldSelect?: (nextStoreState: TState, prevStoreState: TState) => boolean\n  prevValue?: TValue\n}\nexport type TUseStoreArgs = {\n  updateOnMount?: IUpdater\n  updateOnUnmount?: IUpdater\n  selector?: IListener['selector']\n  shouldSelect?: IListener['shouldSelect']\n  shouldUpdate?: IListener['shouldUpdate']\n  debounce?: number\n}\nexport type TAction = (...args: any[]) => TState\n\nexport function selectAll(value: TValue) {\n  return value\n}\n\nexport function always() {\n  return true\n}\n\nexport function whenChanged(a: TValue, b: TValue) {\n  return a !== b\n}\n\nexport default function createStore({\n  initState = {},\n  actions = {}\n}: { initState?: TState; actions?: { [actionName: string]: TAction } } = {}) {\n  const refStore = {\n    current: initState\n  }\n\n  const listeners: Set<IListener> = new Set()\n\n  function updateStore(updater: IUpdater) {\n    const nextStoreState = updater(refStore.current)\n    listeners.forEach(function (listener) {\n      if (listener.shouldSelect && !listener.shouldSelect(nextStoreState, refStore.current)) {\n        return\n      }\n      const nextValue = listener.selector ? listener.selector(nextStoreState) : nextStoreState\n      if (null == listener.shouldUpdate || listener.shouldUpdate(nextValue, listener.prevValue)) {\n        listener(nextValue)\n        if (null != listener.shouldUpdate) {\n          listener.prevValue = nextValue\n        }\n      }\n    })\n    refStore.current = nextStoreState\n    return refStore.current\n  }\n\n  function useStore({\n    updateOnMount,\n    updateOnUnmount,\n    selector,\n    shouldSelect,\n    shouldUpdate = whenChanged,\n    debounce\n  }: TUseStoreArgs = {}) {\n    const [value, setValue] = useState(function () {\n      return selector(updateOnMount ? updateStore(updateOnMount) : refStore.current)\n    })\n\n    const debounceDuration = useRef<number>()\n    debounceDuration.current = debounce\n    const debounceTimer = useRef<ReturnType<typeof setTimeout>>()\n\n    useEffect(function () {\n      const listener = function (nextValue: TValue) {\n        if (debounceTimer.current) {\n          clearTimeout(debounceTimer.current)\n        }\n        if (null == debounceDuration.current) {\n          setValue(nextValue)\n        } else {\n          debounceTimer.current = setTimeout(function () {\n            debounceTimer.current = null\n            setValue(nextValue)\n          }, debounceDuration.current)\n        }\n      }\n      listener.selector = selector\n      listener.shouldSelect = shouldSelect\n      listener.shouldUpdate = shouldUpdate\n      listeners.add(listener)\n      return function () {\n        if (updateOnUnmount) updateStore(updateOnUnmount)\n        listeners.delete(listener)\n      }\n    }, [])\n\n    return value\n  }\n\n  function Consumer(props: TUseStoreArgs & { children: (value: TValue) => React.ReactNode }) {\n    const value = useStore({\n      updateOnMount: props.updateOnMount,\n      updateOnUnmount: props.updateOnUnmount,\n      selector: props.selector,\n      shouldSelect: props.shouldSelect,\n      shouldUpdate: props.shouldUpdate,\n      debounce: props.debounce\n    })\n\n    return props.children(value)\n  }\n\n  const boundActions: { [actionName: string]: TAction } = {}\n  Object.keys(actions).forEach(function (actionName) {\n    boundActions[actionName] = function (...args) {\n      updateStore(function (store: TState) {\n        return actions[actionName].apply(store, args) || store\n      })\n    }\n  })\n\n  function destroy() {\n    listeners.clear()\n  }\n\n  function subscribe(listener: IListener) {\n    listeners.add(listener)\n    return function () {\n      listeners.delete(listener)\n    }\n  }\n\n  function getState(selector: ISelector) {\n    return selector ? selector(refStore.current) : refStore.current\n  }\n\n  return Object.freeze({\n    useStore,\n    Consumer,\n    actions: boundActions,\n    updateStore,\n    getState,\n    subscribe,\n    destroy\n  })\n}\n"]}