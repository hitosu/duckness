{"version":3,"file":"store.js","sourceRoot":"","sources":["../src/store.ts"],"names":[],"mappings":"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","sourcesContent":["import { useEffect, useState, useRef } from 'react'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type TState<S = {}> = S\nexport type TSelectedValue<R = unknown> = R | null | undefined\n\nexport interface ISelector<S, R> {\n  (source: TState<S>): TSelectedValue<R>\n  (...sources: unknown[]): TSelectedValue<R>\n}\n\nexport interface IUpdater<S> {\n  (currentState: TState<S>): TState<S>\n}\n\nexport interface IListener<S = unknown, R = unknown> {\n  (value: TSelectedValue<R>): void\n  selector?: (storeState: TState<S>) => TSelectedValue<R>\n  shouldUpdate?: (nextValue: TSelectedValue<R>, prevValue: TSelectedValue<R>) => boolean\n  shouldSelect?: (nextStoreState: TState<S>, prevStoreState: TState<S>) => boolean\n  prevValue?: TSelectedValue<R>\n}\n\nexport interface TUseStoreArgs<S = unknown, R = unknown> {\n  updateOnMount?: IUpdater<S>\n  updateOnUnmount?: IUpdater<S>\n  selector?: IListener<S, R>['selector']\n  shouldSelect?: IListener<S>['shouldSelect']\n  shouldUpdate?: IListener<S, R>['shouldUpdate']\n  debounce?: number\n}\n\nexport interface TAction<S = unknown> {\n  (state: TState<S>): TState<S>\n  (...args: unknown[]): TState<S>\n}\n\nexport type CreateStoreArguments<S = unknown> = {\n  initState?: TState<S>\n  actions?: Record<string, TAction<S>>\n  isAsync?: boolean\n}\n\nexport type CreateStoreReturnType<S = unknown> = Readonly<{\n  useStore: <R>({\n    updateOnMount,\n    updateOnUnmount,\n    selector,\n    shouldSelect,\n    shouldUpdate,\n    debounce\n  }?: TUseStoreArgs<S, R>) => R\n  Consumer: (\n    props: TUseStoreArgs & {\n      children: (value: TSelectedValue) => React.ReactNode\n    }\n  ) => React.ReactNode\n  actions: {\n    [actionName: string]: TAction\n  }\n  updateStore: (updater: IUpdater<S>) => TState<S>\n  getState: {\n    (): TState<S>\n    <R = unknown>(selector: ISelector<S, R>): TSelectedValue<R>\n  }\n  subscribe: (listener: IListener) => () => void\n  destroy: () => void\n}>\n\nexport function selectAll(value: TSelectedValue) {\n  return value\n}\n\nexport function always() {\n  return true\n}\n\nexport function whenChanged(a: TSelectedValue, b: TSelectedValue) {\n  return a !== b\n}\n\nconst MAX_EXECUTION_TIME = 1000 / 12\n\nexport default function createStore<S>({\n  initState = {} as TState<S>,\n  actions = {},\n  isAsync = false\n}: CreateStoreArguments<S> = {}): CreateStoreReturnType<S> {\n  const refStore: { current: TState<S> } = {\n    current: initState\n  }\n\n  const listeners: Set<IListener> = new Set()\n\n  function updateStore(updater: IUpdater<S>) {\n    const nextStoreState = updater(refStore.current)\n    const queue = [] as [IListener, TSelectedValue][]\n    listeners.forEach(function (listener) {\n      if (listener.shouldSelect && !listener.shouldSelect(nextStoreState, refStore.current)) {\n        return\n      }\n      const nextValue = listener.selector ? listener.selector(nextStoreState) : nextStoreState\n      if (null == listener.shouldUpdate || listener.shouldUpdate(nextValue, listener.prevValue)) {\n        if (isAsync) {\n          queue.push([listener, nextValue])\n        } else {\n          listener(nextValue)\n        }\n        if (null != listener.shouldUpdate) {\n          listener.prevValue = nextValue\n        }\n      }\n    })\n    if (isAsync && queue.length) {\n      requestAnimationFrame(() => {\n        executeQueue(queue)\n      })\n    }\n    refStore.current = nextStoreState\n    return refStore.current\n  }\n\n  function executeQueue(queue: [IListener, TSelectedValue][]) {\n    const start = performance.now()\n    let next = queue.shift()\n    while (next && performance.now() - start < MAX_EXECUTION_TIME) {\n      const listener = next[0]\n      const nextValue = next[1]\n      listener(nextValue)\n      next = queue.shift()\n    }\n    if (queue.length) {\n      requestAnimationFrame(function () {\n        executeQueue(queue)\n      })\n    }\n  }\n\n  function useStore<R>({\n    updateOnMount,\n    updateOnUnmount,\n    selector,\n    shouldSelect,\n    shouldUpdate = whenChanged,\n    debounce\n  }: TUseStoreArgs<S, R> = {}) {\n    const [value, setValue] = useState(function () {\n      return updateOnMount ? selector(updateStore(updateOnMount)) : selector(refStore.current)\n    })\n\n    const debounceDuration = useRef<number>()\n    debounceDuration.current = debounce\n    const debounceTimer = useRef<ReturnType<typeof setTimeout>>()\n\n    useEffect(function () {\n      const listener = function (nextValue: TSelectedValue<R>) {\n        if (debounceTimer.current) {\n          clearTimeout(debounceTimer.current)\n        }\n        if (null == debounceDuration.current) {\n          setValue(nextValue)\n        } else {\n          debounceTimer.current = setTimeout(function () {\n            debounceTimer.current = null\n            setValue(nextValue)\n          }, debounceDuration.current)\n        }\n      }\n      listener.selector = selector\n      listener.shouldSelect = shouldSelect\n      listener.shouldUpdate = shouldUpdate\n      listeners.add(listener)\n      return function () {\n        if (updateOnUnmount) {\n          updateStore(updateOnUnmount)\n        }\n        listeners.delete(listener)\n      }\n    }, [])\n\n    return value\n  }\n\n  function Consumer<R>(props: TUseStoreArgs<S, R> & { children: (value: TSelectedValue<R>) => React.ReactNode }) {\n    const value = useStore({\n      updateOnMount: props.updateOnMount,\n      updateOnUnmount: props.updateOnUnmount,\n      selector: props.selector,\n      shouldSelect: props.shouldSelect,\n      shouldUpdate: props.shouldUpdate,\n      debounce: props.debounce\n    })\n\n    return props.children(value)\n  }\n\n  const boundActions: { [actionName: string]: TAction } = {}\n  Object.keys(actions).forEach(function (actionName) {\n    boundActions[actionName] = function (...args) {\n      updateStore(function (store: TState) {\n        return actions[actionName].apply(store, args) || store\n      })\n    }\n  })\n\n  function destroy() {\n    listeners.clear()\n  }\n\n  function subscribe(listener: IListener) {\n    listeners.add(listener)\n    return function () {\n      listeners.delete(listener)\n    }\n  }\n\n  function getState<R>(selector: ISelector<S, R>) {\n    return selector ? selector(refStore.current) : refStore.current\n  }\n\n  return Object.freeze({\n    useStore,\n    Consumer,\n    actions: boundActions,\n    updateStore,\n    getState,\n    subscribe,\n    destroy\n  } as CreateStoreReturnType<S>)\n}\n"]}